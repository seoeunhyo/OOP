

-- 상속 

(public / 생략) class Person{


	public Person(){}//기본 생성자 
		//실행 
		
	//생성자를 따로 만들지 않으면 자동 생성 
	
	//인수가 다름 : 들어오는 인자값에 따라 하는 역할이 다름 
	public Person(String name){
	
	}
	public Person(String name, int age){
		this(name);//String하나 받는 생성자 호출
		this.age = age; 
	}
	
	
	
	//속성
	private String name;
	int age;
	
	기능 = 메소드 = 함수 
	public final void eat(Food f){//재정의 불가 
	
		
	}
	
	public int walk(){}
	
	public static void run(){ //객체 생성 없이 접근 가능 
	}
	
	
	//객체 생성
	new Person(); //필드를 초기화 + 생성자 호출!!
	
///////////////////////////////////////////////////////////////////////////


class SpiderMan extends Person{//상속 -> spiderMan is a Person 성립 
	속성
	boolean isSpider;
	
	메소드
	@Override //재정의
	public int walk(){
	//부모와는 다른 기능을 작성 
	}
}

public class Student extends Person{
	속성
	String sno;
	
	public Student(){}
	public Student(String sno, String name, int age){
	
	}
	
	메소드
	public void listen(){
	
	}

}
Student st1 = new Student(); //학번, 이름, 나이   
Student st2 = new Student(); 

//walk, run, eat과 같은 함수가 필요 
	class Student extends Person {
		
	}

	public static 제한자 리턴타입 메소드 이름 (){}
	static -> 객체 생성없이 Person.메소드 이름으로 호출 가능 
		-> static이 아닌 속성에 접근할 수 없다. 
	
		
	public final 제한자 리턴타입 메소드 이름 (){}
		-> overriding(재정의)이 불가능
		
		
		
	Person p = new SpiderMan(); //필드를 이용한 다형성
		   p = new Student(); //필드를 이용한 다형성
		   p = new Person(); 
		   
		   p.isSpider = true; --> xxx
		   //다운 캐스팅을 통해 접근 가능하도록 한다.
		   SpiderMan sp = p; //부모 > 자식 
		   SpiderMan sp = (SpiderMan)p; //ObjectDownCasting 

	p.walk();
	sp.walk(); // 둘 다 재정의 된 자식의 메소드를 호출한다.
	//자식에서 재정의 하면 무조건 자식의 메소드를 사용한다 
	//다운 캐스팅 하지 않아도 인터페이스가 자동으로 호출해준다 
	
	

}